<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>AngularJS, BackboneJS, similarities and differences. - Saumya
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="Where there is a will, there is a way.">
    <link rel="stylesheet" href="http://localhost:8080/css/main.css">
    <link rel="stylesheet" href="http://localhost:8080/css/saumya.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>AngularJS, BackboneJS, similarities and differences.</h1>
        <p class="author">Written by <span class="author"><a href="mailto:2saumyaray@gmail.com">Saumya</a></span>
        </p>
        <p class="date">26. November 2015</p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>When learning a new framework or library, its very difficult to look at the same problem from a different perspective. But when you hear a lot like ‘ohh, that library is similar to this’, then the tendency comes to compare it. And when you see similar terminology in both the frameworks, then you are absolutely sure that both are doing the same thing in the same way. I think, thats the main problem here with learning the frameworks like <a href="https://angularjs.org/">AngularJS</a> and <a href="http://backbonejs.org/">BackboneJS</a>. Both of these have their own share of <code>how to</code> and <code>where to</code>, overall they seem completely different, even though the terminolgies seem completely&nbsp;same.         </p>
<p>One such thing is <code>Module</code>. Both these frameworks define <code>Module</code> and use it. Both of them tell to use <code>Module</code> to separate concerns. But then both of them seem completely different while implementing the <code>Module</code>. Umm,&nbsp;Why?!          </p>
<p>The <code>difference</code> is in the <code>Module</code> definition of both the frameworks. And that pushes back someone very new to the frameworks, thinking something wrong either in the frameworks or in the understanding of them. While the truth is something simpler than&nbsp;that.            </p>
<p><a href="https://angularjs.org/">AngularJS</a> uses <a href="http://requirejs.org/docs/whyamd.html#commonjs">CommonJS</a> module declaration.<br><a href="http://backbonejs.org/">BackboneJS</a> uses <a href="http://requirejs.org/docs/whyamd.html#amd"><span class="caps">AMD</span></a> module&nbsp;declaration.          </p>
<p>Once you know this difference, things get a lot easier to understand and will take lesser time than before to get upto speed in either of these. Have a look at the <a href="http://requirejs.org/docs/whyamd.html#definition">Module Definition</a> documentation, it explains the difference of the module definitions. The bottom line is Javascript eco-system gives us <code>two</code> different kind of <code>Module</code> systems. Frameworks use one over the other depending upon their opinion. For example <a href="https://nodejs.org/en/">NodeJS</a> uses <a href="http://requirejs.org/docs/whyamd.html#commonjs">CommonJS</a> approach, while <a href="http://dojotoolkit.org/"><span class="caps">DOJO</span> toolkit</a> uses <a href="http://requirejs.org/docs/whyamd.html#amd"><span class="caps">AMD</span></a>&nbsp;way.          </p>
<p>Now lets understand why this difference matters us as a developer. In <a href="http://requirejs.org/docs/whyamd.html#commonjs">CommonJS</a> style declaration, each file is supposed to be a module which is same as <a href="http://requirejs.org/docs/whyamd.html#amd"><span class="caps">AMD</span></a> way too. The <a href="http://requirejs.org/docs/whyamd.html#commonjs">CommonJS</a> module can expose as many Objects as one wants, to the application level. So that once one <a href="http://requirejs.org/docs/whyamd.html#commonjs">CommonJS</a> module is included, the application has access to all the exposed Objects in that module. For that matter you can understand, why just adding a <code>some-ng-file.js</code> and including that <code>ModuleName</code> in the dependency of an <a href="https://angularjs.org/">AngularJS</a> application, gives a lot of <code>ngObject</code> to play with. Where in <a href="http://requirejs.org/docs/whyamd.html#amd"><span class="caps">AMD</span></a> each module is exposing just one Object. If you want to play with the internals of that Object, you have to call that Object’s properties and methods. This way makes you feel like as if you are working in a Classical (Class based) language rather than Prototypical language. <a href="http://backbonejs.org/">BackboneJS</a> is doing exactly the same thing. Once you have got a <a href="http://backbonejs.org/">BackboneJS</a> module Object, you deal with it as if you are dealing with an Object from a Class. You invoke methods and properties of that&nbsp;Object.           </p>
<p>So one <code>Module</code> in <a href="https://angularjs.org/">AngularJS</a> is exposing a lot to play with and one <code>Module</code> in <a href="http://backbonejs.org/">BackboneJS</a> gives you just one Object to play with. The similarity goes to other frameworks and libraries as I mentioned earlier about <a href="http://dojotoolkit.org/"><span class="caps">DOJO</span> Toolkit</a> and <a href="https://nodejs.org/en/">NodeJS</a>.</p>
<p>Happy coding with&nbsp;modules.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="http://localhost:8080/">« Full blog</a></div>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_shortname = 'saumya';
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        <section class="about"><p><a href="https://saumya.github.io/">Saumya</a> is an iternal seeker.</p>
<p>A maker of things and curious about everything. Continuous learning is, what fuels him. This blog itself, reflects one of many things he is trying at all the time.</p>
<p>He is <a href="https://twitter.com/saumya">@saumya</a> on Twitter. </p>
<span class="nav"><a href="http://localhost:8080/">Blog Home</a><a href="http://localhost:8080/archive.html">Archives</a></span>
        </section>
        <section class="copy">
          <p>&copy; 2019 saumya ray &mdash; powered by&nbsp;     <a href="https://github.com/jnordberg/wintersmith">Wintersmith&nbsp;</a>
            <p> <a href="https://github.com/saumya/wintersmithThemes/tree/master/elegant">Theme Elegant</a></p>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>