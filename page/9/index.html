<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Saumya
    </title>
    <link rel="alternate" href="http://saumya.github.io/ray/feed.xml" type="application/rss+xml" title="Where there is a will, there is a way.">
    <link rel="stylesheet" href="http://saumya.github.io/ray/css/main.css">
    <link rel="stylesheet" href="http://saumya.github.io/ray/css/saumya.css">
  </head>
  <body>
    <header class="header">
      <div class="content-wrap">
        <div class="logo">
          <h1><a href="http://saumya.github.io/ray">Saumya</a></h1>
          <p class="description">Where there is a will, there is a way.</p>
        </div>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article intro">
          <header>
            <p class="date"><span>23. October 2014</span></p>
            <h2><a href="http://saumya.github.io/ray/articles/43/">Upgrading to Cordova 3.4 and above</a></h2>
          </header>
          <section class="content"><p>While trying to upgrade, one of my previous Cordova Android application, to latest <a href="http://cordova.apache.org/">Cordova</a> , noticed that <a href="http://cordova.apache.org/">Cordova</a> now makes it very difficult to switch to a native development workflow. Its not the flow itself, which is difficult, but the information about the flow and to get started with a project which is the problem. If you have ever worked with the native development flow of <a href="http://cordova.apache.org/">Cordova</a> , which I guess you must have, as that was the actual flow in the beginning. Then its exactly the same work flow, but the thing is, its not mentioned anywhere. And in between these, they had introduced a web development workflow and tried forcing to use it. Which itself is not clear and then combined the native workflow with it. Good that, that period is over. But its not clear at all from the docs.
Well, first of all, <a href="http://cordova.apache.org/">Cordova</a> is saying its released the version 4 of the toolkit. When you go to <a href="http://cordova.apache.org/#download">download</a> section for native development workflow, you will <a href="https://www.apache.org/dist/cordova/">not find a version 4</a> ! So, you have to go inside <a href="https://www.apache.org/dist/cordova/platforms/">platforms</a>, there also you will not find version 4. So, I ended up downloading 3.6.4 for android and will suggest everyone to do that for the time being. After downloading the zipped file, extract it to a folder. Navigate to the folder and fireup the cordova create command to create a project.
Next is adding the plugins, because now <a href="http://cordova.apache.org/">Cordova</a> does not include plugins by default. For that, one has to go back to Cordova <span class="caps">CLI</span> and that can be done with Node and NPM. But instead of running Cordova to add plugins, one has to run Plugman to install&nbsp;plugins.</p>
<p>The flow&nbsp;is </p>
<ul>
<li>download Cordova Native development&nbsp;package</li>
<li>download Node and&nbsp;<span class="caps">NPM</span></li>
<li>install Cordova and Plugman through&nbsp;<span class="caps">NPM</span></li>
<li>create project from inside the dowloaded Cordova&nbsp;folder</li>
<li>navigate to the project&nbsp;folder</li>
<li>run the Plugman command to add plugins to the&nbsp;project</li>
</ul>
<p>Happy&nbsp;Coding.</p>

          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>30. September 2014</span></p>
            <h2><a href="http://saumya.github.io/ray/articles/42/">Dojo Toolkit, Widget.</a></h2>
          </header>
          <section class="content"><p><a href="http://dojotoolkit.org/">Dojo Toolkit</a> has a component library named as <code>Dijit</code>. Each component in this library is known as a <code>Widget</code>. It is better to know the <code>dijit</code> framework vocabulary before going further inside&nbsp;it. </p>
<ul>
<li>Normally each <code>.js</code> file represents a <code>Class</code>.</li>
<li>Each file, whose name starts with <code>_</code> (underscore) is <code>not a concrete</code> class. That means, this class is supposed to be extended to be used, <code>never directly used</code> as&nbsp;is.</li>
<li>Members inside a class, properties and methods, whose name starts with <code>_</code> (underscore) are <code>private</code></li>
<li>A class is defined by <code>declare()</code> </li>
</ul>
<p><a href="http://dojotoolkit.org/">Dojo</a> now supports <span class="caps">AMD</span> modules. So the module definition is pretty straight forward as in standard module definition. If you have ever used any other framework such as <a href="http://backbonejs.org/">BackboneJS</a>, you already know, how to declare, extend, load and use a module and a&nbsp;class. </p>
<p>Now, lets see what <code>Widget</code> brings to the rules table. Each Widget has a life-cycle of its own. The lifecycle methods are as below in&nbsp;sequence.</p>
<ul>
<li>constructor()</li>
<li>postMixInProperties()</li>
<li>buildRendering()</li>
<li>setters and getters, example is&nbsp;set(“myProperty”,value)</li>
<li>postCreate()</li>
<li>startup()</li>
<li>destroy()</li>
</ul>
<p>There are few methods which also be called in some widgets, such&nbsp;as</p>
<ul>
<li>resize()</li>
</ul>
<p>Each <code>Widget</code> is supposed to <code>Extend</code> the <code>_WidgetBase</code> class defined in <code>dijit/_WidgetBase</code> package. Sometimes, it is necessary to use template strings or templates inside a  Widget. In that case, the <code>Widget</code> extends <code>_WidgetBase</code> and <code>_TemplatedMixin</code>, defined in <code>dijit/_WidgetBase</code> and <code>dijit/_TemplatedMixin</code> package&nbsp;respectively.</p>
<p>After creation of each child <code>Widget</code> inside the parent Widget, its necessary to call the <code>startup()</code> method of the child Widget. Since <code>startup()</code> call goes through all the child widgets of a container Widget, its better to add all the child Widgets to the parent Widget and call parent’s <code>startup()</code>, which will call <code>startup()</code> of each child Widget.
While writing a custom Widget, its necessary to override parent’s lifecycle methods. At the sametime, it is necessary to continue the lifecycle of the Widget. So a call to parent’s method is necessary. In most of all programming languages it is done with a <code>super()</code> call. In <code>dijit</code> framework its called&nbsp;as</p>
<ul>
<li>this.inherited(arguments);</li>
</ul>
<p>So inside each of the above life-cycle methods, a call to <code>this.inherited(arguments);</code> is necessary, either in the beginning or as the last line of the&nbsp;method.</p>
<p>A custom <code>Widget</code> has either of the 2 properties below or sometimes both, to add child widgets to&nbsp;itself.</p>
<ul>
<li>this.domNode</li>
<li>this.containerNode</li>
</ul>
<p>Now to add child widgets to the parent widget there are methods&nbsp;like</p>
<ul>
<li>addChild()</li>
</ul>
<p>Well, this post may seem a lot but the idea is to make you aware of the vocabulary and some background to <code>dijit</code> infrastructure. For a basic and complete <code>example</code> <a href="https://github.com/saumya/dojo101/blob/master/dojo-release-1.10.0-src/myWidgets/rayWidget3.js">have a look at this widget</a>.</p>
<p>Happy&nbsp;Coding.</p>

          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>29. September 2014</span></p>
            <h2><a href="http://saumya.github.io/ray/articles/41/">Getting started with, Dojo Toolkit</a></h2>
          </header>
          <section class="content"><p>To begin with, <a href="http://dojotoolkit.org/">Dojo Toolkit</a> or simply referred to as <a href="http://dojotoolkit.org/">Dojo</a> is one of many libraries in javascript. First thing to do is, like any other javascript libraries, make sure which version of library you are studying and using. <a href="http://dojotoolkit.org/">Dojo</a> has gone through major upgrades and if you are trying to do things the new way of <a href="http://dojotoolkit.org/">Dojo</a> then better get to know the <a href="http://dojotoolkit.org/documentation/tutorials/1.10/modern_dojo/">new version</a>. We will be focusing on the new version only(currently <code>1.10</code>) and referring to old one, wherever&nbsp;necessary.</p>
<p><a href="http://dojotoolkit.org/">Dojo Toolkit</a> has got a combination&nbsp;following</p>
<ul>
<li>A bare bone of functionality ( <code>dojo</code> )</li>
<li>A widget library ( <code>dijit</code> )</li>
<li>An experimental library ( <code>dojox</code> )</li>
<li>An Unit testing&nbsp;framework</li>
<li>A compiler to do the minification and&nbsp;optimisation</li>
</ul>
<p>A lot of javascript libraries try to implement the classical programming concepts and <a href="http://dojotoolkit.org/">Dojo</a> is another one of them. So, if you are a purist in Javascript, <a href="http://dojotoolkit.org/">Dojo</a> will dissapoint you. The functional nature of Javascript is also eliminated here. <a href="http://dojotoolkit.org/">Dojo</a> clearly disagrees to say that <code>function</code> is <code>a first class citizen</code>, which is again denying another nice feature of javascript. Well, but if you are coming from a classical programming background, that means from a programming language which is class based like Java, then <a href="http://dojotoolkit.org/">Dojo</a> will seem natural. So, we will refer them in classical terms rather than Javascript&nbsp;terms.</p>
<p>The core functionality of the toolkit is wrapped in a package called <code>dojo</code>. Everythig that runs in the toolkit depends on this basic package. Next is <code>dijit</code>, which can be called as a component library or in dojo’s terms these are widgets. Now <code>dojox</code> is a package containing experimental widgets, which will eventually go into <code>dijit</code> , once they are stable enough. Since widgets have to live a life of their own, there is a flow of lifecycle events. It is now obvious that any application using these widgets have to abide to these lifecycle events and some rules as a whole. In Dojo’s terms these are framework&nbsp;rules.</p>
<p>Happy&nbsp;Coding.</p>

          </section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="http://saumya.github.io/ray/page/8/">« Newer</a><a href="http://saumya.github.io/ray/page/10/">Next page »</a>
        </div>
        <section class="about"><p><a href="http://www.saumyaray.com">Saumya</a> believes in The God.</p>
<p>A maker of things and curious about everything. Continuous learning is, what fuels him. This blog itself, reflects one of many things he is trying at all the time.</p>
<p>He is <a href="https://twitter.com/saumya">@saumya</a> on Twitter. </p>
<span class="nav"><a href="http://saumya.github.io/ray/">Blog Home</a><a href="http://saumya.github.io/ray/archive.html">Archives</a></span>
        </section>
        <section class="copy">
          <p>&copy; 2016 saumya ray &mdash; powered by&nbsp;     <a href="https://github.com/jnordberg/wintersmith">Wintersmith&nbsp;</a>
            <p> <a href="https://github.com/saumya/wintersmithThemes/tree/master/elegant">Theme Elegant</a></p>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>