<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Saumya
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="Where there is a will, there is a way.">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="http://localhost:8080/css/saumya.css">
  </head>
  <body>
    <header class="header">
      <div class="content-wrap">
        <div class="logo">
          <h1><a href="http://localhost:8080">Saumya</a></h1>
          <p class="description">Where there is a will, there is a way.</p>
        </div>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article intro">
          <header>
            <p class="date"><span>18. January 2015</span></p>
            <h2><a href="/articles/51/">Making crossplatform CLI application with HAXE</a></h2>
          </header>
          <section class="content"><p>When I first heard about <span class="caps">CLI</span> applications, I thought it might be shipping with the <span class="caps">OS</span> itself. Then I found that we can write our own <span class="caps">CLI</span> applications. At that point I assume that well, just a <span class="caps">CLI</span> application, means it runs everywhere. But actually <span class="caps">CLI</span> applications by default are not crossplatform! Yes, I realised it much later. In order to have a crossplatform <span class="caps">CLI</span> app, one needs all the required environment to compile to and compile for a particular<span class="widont">&nbsp;</span><span class="caps">OS</span>.         </p>
<p><a href="http://haxe.org/"><span class="caps">HAXE</span></a> comes in handy in this case. One can make a crossplatfom <span class="caps">CLI</span> app with just one code base. Ofcourse you need the required environment to compile to that particular environment. There is even a shorter way to this, compile for <a href="http://nekovm.org"><span class="caps">NEKO</span></a> virtual machine. This <a href="http://nekovm.org"><span class="caps">NEKO</span></a> <span class="caps">VM</span> ships with <a href="http://haxe.org/"><span class="caps">HAXE</span></a>. Once you compile to <a href="http://nekovm.org"><span class="caps">NEKO</span></a>, all you do is package all the <a href="http://nekovm.org"><span class="caps">NEKO</span></a> dependencies and there you have a crossplatform <span class="caps">CLI</span> for every <span class="caps">OS</span>. Here we will compile to <a href="http://nekovm.org"><span class="caps">NEKO</span></a> and run through <a href="http://nekovm.org"><span class="caps">NEKO</span></a>, but just keep in mind that the same code can be compiled to <span class="caps">CPP</span>(C++) to produce true native <span class="caps">CLI</span>.<br>Lets begin with the compiler settings or the build file. The <code>.hxml</code> file has the following<span class="widont">&nbsp;</span>content.</p>
<pre><code class="language-haxe"><span class="meta"># <span class="caps">HAXE</span> build</span>
<span class="meta"># Defining the application entry</span>
-main MyCliApp
<span class="meta"># <span class="caps">NEKO</span> : compilation</span>
-neko bin/myCliApp.n
<span class="meta">#</span>
<span class="meta"># <span class="caps">CPP</span> : compilation</span>
<span class="meta">#-cpp bin/cpp/</span></code></pre>
<p>We are setting up for compiling to <a href="http://nekovm.org"><span class="caps">NEKO</span></a> but then we have the options commented out for compiling to <span class="caps">CPP</span>. If we want to compile for the C++ target, then comment out the <a href="http://nekovm.org"><span class="caps">NEKO</span></a> target and enable the <span class="caps">CPP</span>(C++) target. Well, this compilation will create a file named <code>myCliApp.n</code> inside the ‘bin’ folder. To run the file, we have to navigate to the ‘bin’ folder and run with <a href="http://nekovm.org"><span class="caps">NEKO</span></a> as<span class="widont">&nbsp;</span>below.  </p>
<pre><code class="language-haxe">neko ./myCliApp.n</code></pre>
<p>Thats about compilation and running. Lets get back to coding. There is no surprise here as all we have to do is, get the right package and class from <a href="http://haxe.org/"><span class="caps">HAXE</span></a> and use it. Here is the <a href="https://github.com/saumya/HAXE-CLI-101">Git repo</a> for this example. The application entry initialises ‘PrintInfo’ Class. That class prints the information that we want to show to the user and finally asks the name of the use. As user inputs the name, it greets the user and moves to our defined command prompt. We have setup some commands to display. Depending upon user input the necessary commands are executed. All these are happening in <code>MyCli.hx</code>  Class. The <a href="https://github.com/saumya/HAXE-CLI-101/blob/master/com/saumya/cli/MyCli.hx">code is commented</a> for easy reference in <a href="https://github.com/saumya/HAXE-CLI-101">this repo</a>. Here is the <a href="https://github.com/saumya/HAXE-CLI-101/blob/master/com/saumya/cli/MyCli.hx">direct link</a> to the<span class="widont">&nbsp;</span>class. </p>
<p>Happy coding.</p>

          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>17. January 2015</span></p>
            <h2><a href="/articles/50/">HAXE and NodeJS</a></h2>
          </header>
          <section class="content"><p>Continuing the sudy of javascript target of <a href="http://haxe.org/"><span class="caps">HAXE</span></a> we will focus on <a href="http://nodejs.org/">NodeJS</a> this time. Before we move on, lets remind ourselves the things to expect from the <a href="http://haxe.org/"><span class="caps">HAXE</span></a> toolchain by going through the previous two introductions, here is the <a href="http://saumya.github.io/ray/articles/47/">first</a> and the <a href="http://saumya.github.io/ray/articles/48/">second</a> post.<br>Thats about <a href="http://haxe.org/"><span class="caps">HAXE</span></a>, now a little about <a href="http://nodejs.org/">NodeJS</a>. In <a href="http://nodejs.org/">NodeJS</a> the concept of modules is very common to make some re-usable code. In general, modules hide everything by default. In class based languages we can call them as <code>private</code> elements. To make something <code>public</code> , we have to use <code>exports</code> keyword in <a href="http://nodejs.org/">NodeJS</a>.           </p>
<p>For example, if we have a file names <code>one.js</code> as</p>
<pre><code class="language-javascript">exports.publicFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);
}</code></pre>
<p>Now, in <a href="http://nodejs.org/">NodeJS</a>, we can write something<span class="widont">&nbsp;</span>as          </p>
<pre><code class="language-javascript"><span class="keyword">var</span> oneObj = <span class="built_in">require</span>(<span class="string">'./one'</span>);
oneObj.publicFunction();</code></pre>
<p>Thats first kind of modules we have. There is another kind of modules in <a href="http://nodejs.org/">NodeJS</a>, where instead of exposing each individual elements from the modules, it exposes a <code>Constructor</code> function. This is done with <code>module.exports</code> in stead of only <code>exports</code>.          </p>
<pre><code class="language-javascript"><span class="built_in">module</span>.exports.MyObjConstructor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'New Object'</span>);
}</code></pre>
<p>This second one is looked at as classical concepts of programming, where each <span class="caps">JS</span> file is kind of a Class file.<br>The dynamic and fun nature of javascript allows us to use the first way of exposing individual elements to actually expose a constructor function too. Is not it ?! Why we think about that! Because <a href="http://haxe.org/"><span class="caps">HAXE</span></a> generated javascript is actually doing that. Smart.<br>
            <p class="more"><a href="/articles/50/">more</a></p>
          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>13. January 2015</span></p>
            <h2><a href="/articles/49/">Dojo Toolkit, require and events.</a></h2>
          </header>
          <section class="content"><p>Well, lets say this, if you are working on <a href="http://dojotoolkit.org/">Dojo Toolkit</a>, you are working on a legacy application. Since <a href="http://dojotoolkit.org/">Dojo Toolkit</a> is releasing its newer versions, you need to change your application to newer codebase. Currently <a href="http://dojotoolkit.org/">Dojo Toolkit</a> is leveraging <a href="http://requirejs.org/docs/whyamd.html#amd"><span class="caps">AMD</span></a> for modules and Javascript files. Which is very new for this toolkit and veteran developers in this toolkit may find its very<span class="widont">&nbsp;</span>different.          </p>
<p>Previously, when we needed some <span class="caps">JS</span> code, its simply done by making a ‘require’<span class="widont">&nbsp;</span>call.          </p>
<pre><code class="language-javascript">dojo.require(<span class="string">"dojo.string"</span>);
<span class="comment">//then use it</span>
dojo.string.trim(<span class="string">"  I Like Trim Strings "</span>);</code></pre>
<p>Now it looks<span class="widont">&nbsp;</span>as          </p>
<pre><code class="language-javascript"><span class="built_in">require</span>([<span class="string">"dojo/string"</span>, <span class="string">"dojo/domReady!"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">string</span>)</span>{
  string.trim(<span class="string">"  I Like Trim Strings "</span>);
});</code></pre>
<p>Well that may seems fine now, but then what happens when we need something inside that <code>require</code> itself? Actually, its simpler than it seems, we can have <code>require</code> inside another require<span class="widont">&nbsp;</span>too.          </p>
<pre><code class="language-javascript"><span class="built_in">require</span>([<span class="string">"dojo/domReady!"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="comment">//<span class="caps">DOM</span> is ready, load another module</span>
    <span class="built_in">require</span>([<span class="string">"dojo/string"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">string</span>)</span>{
      string.trim(<span class="string">"  I Like Trim Strings "</span>);
    });
});</code></pre>
<p>Thats nice. Here <a href="http://dojotoolkit.org/reference-guide/1.7/dojo/require.html">is the official documentation</a>. The introduction to <a href="http://dojotoolkit.org/documentation/tutorials/1.10/modern_dojo/">modern dojo</a> is here.<br>Another nice utility is <a href="http://dojotoolkit.org/reference-guide/1.10/dojo/topic.html">topic</a>. This is kind of central event dispatching and listening station. All one has to do is, dispatch events through <a href="http://dojotoolkit.org/reference-guide/1.10/dojo/topic.html">topic</a> and listen through it too. These are called <code>publish</code> and <code>subscribe</code> of events.          </p>
<pre><code class="language-javascript"><span class="built_in">require</span>([<span class="string">"dojo/topic"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">topic</span>)</span>{
    topic.subscribe(<span class="string">"some/topic"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arguments</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">"received:"</span>, <span class="built_in">arguments</span>);
    });
    <span class="comment">// ...</span>
    topic.publish(<span class="string">"some/topic"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>);
});</code></pre>
<p>The other kind of events are <span class="caps">DOM</span> events and <a href="http://dojotoolkit.org/reference-guide/1.10/dojo/on.html#dojo-on">they are handled with the ‘on’</a><span class="widont">&nbsp;</span>module.          </p>
<p>Happy coding.</p>

          </section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/page/11/">&laquo; Newer</a><a href="/page/13/">Next page &raquo;</a>
        </div>
        <section class="about"><p><a href="https://saumya.github.io/">Saumya</a> is an iternal seeker.</p>
<p>A maker of things and curious about everything. Continuous learning is, what fuels him. This blog itself, reflects one of many things he is trying at all the time.</p>
<p>Talk to <a href="https://twitter.com/saumya">@saumya</a> on Twitter. </p>
<span class="nav"><a href="http://localhost:8080/">Blog Home</a><a href="http://localhost:8080/archive.html">Archives</a><a href="http://localhost:8080/feed.xml">Feed</a></span>
        </section>
        <section class="copy">
          <p>&copy; 2019 Saumya Ray &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
            <p><a href="https://github.com/saumya/wintersmithThemes/tree/master/elegant">Theme Elegant</a></p>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>